import numpy as np
import magpylib as magpy
from magpylib_force.mesh import mesh_cuboid
from magpylib_force.utility import check_input_anchor
from magpylib_force.utility import check_input_targets_Cuboid
from magpylib_force.utility import check_input_targets_Polyline


def getFTcube(sources, targets, eps=1e-5, anchor=None, squeeze=True):
    """
    Compute force and torque acting on a Cuboid magnet.

    Parameters
    ----------
    sources: source and collection objects or 1D list thereof
        Sources that generate the magnetic field. Can be a single source (or collection)
        or a 1D list of l sources and/or collection objects.

    targets: Cuboid object or 1D list of Cuboid objects
        Force and Torque acting on targets in the magnetic field generated by the sources
        will be computed. A target must have a valid mesh parameter.
    
    eps: float, default=1e-5
        The magnetic field gradient is computed using finite differences (FD). eps is
        the FD step size. A good value is 1e-5 * characteristic system size (magnet size,
        distance between sources and targets, ...).
    
    anchor: array_like, default=None
        The Force adds to the Torque via the anchor point. For a freely floating magnet
        this would be the barycenter. If `anchor=None`, this part of the Torque computation
        is ommitted.

    squeeze: bool, default=True
        The output of the computation has the shape (n,3) where n corresponds to the number
        of targets. By default this is reduced to (3,) when there is only one target.
    """
    anchor = check_input_anchor(anchor)
    targets = check_input_targets_Cuboid(targets)
    # MISSING: allow Collections

    # number of Cuboids
    tgt_number = len(targets)

    # number of instances of each Cuboid
    inst_numbers = np.array([np.prod(tgt.mesh) for tgt in targets])

    # total number of instances
    no_inst = np.sum(inst_numbers)

    # cumsum of number of instances (used for indexing)
    insti = np.r_[0, np.cumsum(inst_numbers)]

    # field computation positions (1xfor B, 6x for gradB)
    POSS = np.zeros((no_inst,7,3))

    # moment of each instance
    MOM = np.zeros((no_inst,3))

    # MISSING: eps should be defined relative to the sizes of the system
    eps_vec = np.array([(0,0,0), (eps,0,0), (-eps,0,0), (0,eps,0), (0,-eps,0), (0,0,eps), (0,0,-eps)])

    for i,tgt in enumerate(targets):
        tgt_vol = np.prod(tgt.dimension)
        inst_mom = tgt.magnetization * tgt_vol / inst_numbers[i]
        MOM[insti[i]:insti[i+1]] = inst_mom

        mesh = mesh_cuboid(tgt)
        for j,ev in enumerate(eps_vec):
            POSS[insti[i]:insti[i+1],j] = mesh + ev + tgt.position

    BB = magpy.getB(sources, POSS, sumup=True)
    gradB = (BB[:,1::2]-BB[:,2::2]) / (2*eps)
    gradB = np.swapaxes(gradB,0,1)

    Fs = np.sum((gradB*MOM),axis=2).T
    #Ts = np.zeros((no_inst,3))
    Ts = np.cross(BB[:,0], MOM)
    if anchor is not None:
        Ts -= np.cross(POSS[:,0]-anchor, Fs)

    T = np.array([np.sum(Ts[insti[i]:insti[i+1]],axis=0) for i in range(tgt_number)])
    F = np.array([np.sum(Fs[insti[i]:insti[i+1]],axis=0) for i in range(tgt_number)])

    if squeeze:
        F = np.squeeze(F)
        T = np.squeeze(T)

    return F, T



def getFTwire(sources, targets, anchor=None, squeeze=True):
    """
    compute force acting on tgt Polyline

    info:
    targets = Polyline objects
    segements = linear segments within Polyline objects
    instances = computation instances, each segment is split into `mesh` points
    """

    anchor = check_input_anchor(anchor)
    targets = check_input_targets_Polyline(targets)
    # MISSING: allow Collections

    # number of Polylines
    tgt_number = len(targets)

    # segments of each Polyline
    seg_numbers = np.array([len(tgt.vertices)-1 for tgt in targets])

    # number of mesh-points of each Polyline
    mesh_numbers = np.array([tgt.mesh for tgt in targets])

    # number of instances of each Polyline
    inst_numbers = seg_numbers*mesh_numbers

    # total number of instances
    no_inst = np.sum(inst_numbers)

    # cumsum of number of instances (used for indexing)
    insti = np.r_[0, np.cumsum(inst_numbers)]

    # path vector of each instance
    LVEC = np.zeros((no_inst,3))
    # central location of each instance
    POSS = np.zeros((no_inst,3))
    # current of each instance
    CURR = np.zeros((no_inst,))

    for i,tgt in enumerate(targets):
        verts = tgt.vertices
        mesh = mesh_numbers[i]

        lvec = np.repeat(verts[1:] - verts[:-1], mesh, axis=0)/mesh
        LVEC[insti[i]:insti[i+1]] = lvec

        CURR[insti[i]:insti[i+1]] = [tgt.current]*mesh*seg_numbers[i]
        
        for j in range(seg_numbers[i]):
            poss = np.linspace(verts[j]+lvec[j*mesh]/2, verts[j+1]-lvec[j*mesh]/2, mesh) + tgt.position
            POSS[insti[i]+mesh*j:insti[i]+mesh*(j+1)] = poss

    # field of every instance
    B = magpy.getB(sources, POSS, sumup=True)

    # force on every instance
    F = (CURR * np.cross(LVEC, B).T).T

    # torque on every instance + sumup for every target
    if anchor is not None:
        T = np.cross(anchor - POSS, F)
        T = np.array([np.sum(T[insti[i]:insti[i+1]],axis=0) for i in range(tgt_number)])
    else:
        T = np.zeros((tgt_number,))

    # sumup force for every target
    F = np.array([np.sum(F[insti[i]:insti[i+1]],axis=0) for i in range(tgt_number)])

    # squeeze output
    if squeeze:
        F = np.squeeze(F)
        T = np.squeeze(T)

    return F, T
